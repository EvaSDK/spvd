#!/usr/bin/python
# -*- coding: utf-8 -*-

""" Body of the supervision daemon code. """

import os
import sys
import optparse
import resource
import re

import signal
import ConfigParser

import sjutils
import threading

VERSION = "@PACKAGE_VERSION@"

# Default daemon parameters.
# File mode creation mask of the daemon.
UMASK = 0

# Default working directory for the daemon.
WORKDIR = "/"

# Default maximum for the number of available file descriptors.
MAXFD = 1024

DFLT_PIDFILE = "@localstatedir@/run/spvd/spvd.pid"
DFLT_LOGFILE = "@localstatedir@/log/spvd/spvd.log"
DFLT_CONFFILE = "@sysconfdir@/spvd.conf"

sys.path.insert(1, '@pkgdatadir@/plugins/')
sys.path.insert(1, '@pkgdatadir@/')

# The standard I/O file descriptors are redirected to /dev/null by default.
if (hasattr(os, "devnull")):
    REDIRECT_TO = os.devnull
else:
    REDIRECT_TO = "/dev/null"

class SpvdPluginLogger:
    """ Logger facility for spvd plugins """

    def __init__(self, plugin_name, log_dir, log_ext = '.log'):
        """ Init method. """

        self.log_dir = log_dir + '/' + plugin_name + '/'
        self.name = plugin_name
        self.files = { }
        self.log_ext = log_ext

        if os.path.exists(self.log_dir) is False:
            os.mkdir(self.log_dir)
        log_file = self.log_dir + self.name + self.log_ext
        if os.path.exists(log_file) is False:
            f = open(log_file, 'w')
            f.close()
        # '%BASIC%' is a special target file refering to 'plugin_name.log'
        self.files['%BASIC%'] = sjutils.Logger2(log_file)

    def log(self, target, msg):
        """ Log message in target file """

        if self.files.get(target) is None:
            log_file = self.log_dir + self.name + '-' + target + self.log_ext
            if os.path.exists(log_file) is False:
                f = open(log_file, 'w')
                f.close()
            self.files[target] = sjutils.Logger2(log_file)
        self.files[target].write(msg)

class Monitor:
    """ Dummy class holding basic functions of the daemon. """

    def __init__(self, monitor_options):
        """ Init method. """

        self.pool = None
        self.plugins = {}
        self.plugins_params = {}
        self.dismiss = threading.Event()
        self.options = monitor_options

        if not self.options.nodaemon:
            self.log = sjutils.Logger2(self.options.logfile)
            self.log.redirect_stdout_stderr()
        else:
            # This is not portable but who cares ?
            self.log = sjutils.Logger2('/dev/stdout')

        self.parse_config(self.options.conffile)

        signal.signal(signal.SIGTERM, self.handle_signal)
        signal.signal(signal.SIGINT,  self.handle_signal)

    def parse_config(self, configfile):
        """ Parse spvd configuration file. """

        config = ConfigParser.RawConfigParser()
        config.read(configfile)

        plugins_require = {}
        plugins_provided = {}

        plugins_optional = {}

        for section in config.sections():
            options = dict(config.items(section))
            if section == 'spvd':
                self.plugins = dict([(plugin, plugin) for plugin in options['plugins'].split(', ') if plugin])
                self.distant_url = options['distant_url'].strip()
                self.log.write('Using %s' % self.distant_url)
            elif section.startswith('spvd:'):
                plugin_name = section.split(':')[1]
                if not plugin_name in self.plugins_params:
                    self.plugins_params[plugin_name] = {}

                plugin_attrs = __import__(plugin_name)

                if not plugin_name in plugins_require:
                    plugins_require[plugin_name] = plugin_attrs.Plugin.require
                if not plugin_name in plugins_optional:
                    plugins_optional[plugin_name] = plugin_attrs.Plugin.optional

                plugin_options = {}
                for key, value in options.iteritems():
                    if key == 'debug':
                        plugin_options[key] = value == 'True' and True or False
                    elif key in plugins_require[plugin_name] or key in plugins_optional[plugin_name]:
                        try:
                            if key in plugins_require[plugin_name]:
                                option_type = plugins_require[plugin_name][key]
                                if not plugin_name in plugins_provided:
                                    plugins_provided[plugin_name] = []
                                plugins_provided[plugin_name].append(key)
                            else:
                                option_type = plugins_optional[plugin_name][key]
                            plugin_options[key] = option_type(value)
                        except:
                            self.log.write("Wrong format (should be %s): %s in [spvd:%s]" % (option_type.__name__, key, plugin_name))
                            self.shutdown()

                self.plugins_params[plugin_name].update(plugin_options)

        for plugin_name, requirement in plugins_require.iteritems():
            for key in requirement:
                if not key in plugins_provided[plugin_name]:
                    self.log.write("Need option: %s in [spvd:%s]" % (key, plugin_name))
                    self.shutdown()

        if not len(self.plugins):
            self.log.write("*** there is no plugin configured ***")
            self.shutdown()

    def handle_signal(self, signum=0, frame=None):
        """ Handle signals telling all threads to exit. """

        self.log.write('*** received Signal %d ***' % signum)

        if frame:
            del frame

        self.dismiss.set()
        self.log.write('dismiss event sent')

    def shutdown(self):
        """ Shutdown spvd cleanly. """

        self.log.write('threads alive: %d' % threading.activeCount())
        self.pool.dismiss_workers(len(self.plugins))
        self.log.write('workers dismissed')
        self.pool.join_all_dismissed_workers()
        self.log.write('workers joined')

        self.log.write("*** spvd version %s, terminated ***" % VERSION)
        # Shows a warning when daemonized while it should not
        #self.log.close()
        if not self.options.nodaemon:
            os.remove(self.options.pidfile)
        sys.exit(os.EX_OK)

    def plugin_instance_start(self, plugin):
        """ Starts a supervision plugin. """

        try:
            plugin_classes = __import__(plugin)
        except ImportError:
            self.log.write('failed to load %s plugin' % plugin)
            self.pool.dismiss_workers(1)
            return False

        if self.options.logfile.find('/') == -1:
            logger = SpvdPluginLogger(plugin_classes.PLUGIN_NAME, '')
        elif self.options.logfile[0] == '/' and self.options.logfile.find('/', 1) == -1:
            logger = SpvdPluginLogger(plugin_classes.PLUGIN_NAME, '/')
        else:
            logger = SpvdPluginLogger(plugin_classes.PLUGIN_NAME, self.options.logfile.rsplit('/', 1)[0])
        if plugin in self.plugins_params:
            inst = plugin_classes.Plugin(logger, self.dismiss, self.distant_url, params=self.plugins_params[plugin])
        else:
            inst = plugin_classes.Plugin(logger, self.dismiss, self.distant_url)
            self.pool.dismiss_workers(1)

        # Wait for plugin thread to join
        inst.join()

        self.log.write('plugin %s joined' % plugin)
        return True

    def plugin_instance_stop(self, request, result):
        """ Stops a supervision plugin. """

        self.log.write("request %s finished" % request.request_id)

    def run(self):
        """ Main function. """

        self.log.write("*** spvd version %s, started ***" % VERSION)
        self.pool = sjutils.threadpool.ThreadPool(len(self.plugins))

        for plugin in self.plugins:
            req = sjutils.threadpool.WorkRequest(
                self.plugin_instance_start,
                [plugin],
                None,
                request_id=plugin,
                callback=self.plugin_instance_stop
            )

            self.pool.queue_request(req)
            self.log.write("plugin %s/id:%s queued" % (plugin, req.request_id))

        while not self.dismiss.isSet():
            for thread in threading.enumerate():
                if hasattr(thread, 'daemon') and thread.daemon:
                    self.log.write('no daemon thread [%s] is alive' % thread.getName())
            self.pool.poll()
            self.dismiss.wait(10)

        self.shutdown()

def daemonize(options):
    """ Detach process from the controlling terminal and run it as a daemon. """

    if os.path.isfile(options.pidfile):
        fd = open(options.pidfile)
        old_pid = int(fd.read())
        fd.close()
        if os.path.isfile("/proc/%d/cmdline" % old_pid):
            print "There is already a running instance"
            os._exit(os.EX_OK)

    try:
        pid = os.fork()
    except OSError, error:
        raise Exception, "%s [%d]" % (error.strerror, error.errno)

    if pid == 0:
        # The first child.
        os.setsid()
        pidfile = open(options.pidfile, 'w')
        pidfile.write("%d" % os.getpid())
        pidfile.close()
        Monitor(options).run()

    else:
        os._exit(os.EX_OK)

    # Resource usage information.
    maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
    if (maxfd == resource.RLIM_INFINITY):
        maxfd = MAXFD

    # Iterate through and close all file descriptors.
    for fd in range(0, maxfd):
        try:
            os.close(fd)
        except OSError:	# ERROR, fd wasn't open to begin with (ignored)
            pass

    os.open(REDIRECT_TO, os.O_RDWR)	# standard input (0)

    # Duplicate standard input to standard output and standard error.
    os.dup2(0, 1)			# standard output (1)
    os.dup2(0, 2)			# standard error (2)

    return os.EX_OK

if __name__ == "__main__":

    parser = optparse.OptionParser(
        version="%prog " + VERSION, option_list=[
        optparse.Option("-f", "--conf",       dest="conffile", help="Define spvd conf file", metavar="FILE", default=DFLT_CONFFILE),
        optparse.Option("-l", "--log",        dest="logfile",  help="Define spvd log file",  metavar="FILE", default=DFLT_LOGFILE),
        optparse.Option("-p", "--pid",        dest="pidfile",  help="Define spvd pid file",  metavar="FILE", default=DFLT_PIDFILE),
        optparse.Option("-n", "--no-daemon",  dest="nodaemon", help="Define spvd log file",  action="store_true",  default=False)]
        )

    (parsed_options, args) = parser.parse_args()

    if not parsed_options.nodaemon:
        retCode = daemonize(parsed_options)
    else:
        Monitor(parsed_options).run()

    sys.exit(retCode)

